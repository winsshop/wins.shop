<!DOCTYPE html>
<html lang="ru">
<head>
    <!-- Все предыдущие метатеги и стили остаются без изменений -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Каталог кроссовок</title>
    <link rel="icon" href="data:,">
    <style>
        /* Все стили из предыдущей версии сохраняются */
    </style>
</head>
<body>
    <!-- HTML-структура из предыдущей версии сохраняется -->

    <script>
        // Константы и конфигурация остаются без изменений
        const API_KEY = "AIzaSyCLIf11ZJ-MOQvV8XUjzUYbXNXXlgMn8XQ";
        const SHEET_ID_SHORT = "1cO0HPxLVgYbc0TayeF6dJf0Z1G8aRqwuK56mXMnKk5U";
        const SHEET_ID_LONG = "1ZUdfEr8ztkJnUWpj7j0H8MvrMRLVt0Fo2NI71KvCmgs";
        const IMAGE_PROXY = "https://images.weserv.nl/?url=";
        const ITEMS_PER_PAGE = 12;

        // Добавляем недостающие функции
        async function fetchSheet(sheetId, range) {
            const url = `https://sheets.googleapis.com/v4/spreadsheets/${sheetId}/values/${encodeURIComponent(range)}?key=${API_KEY}`;
            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const data = await response.json();
                return data.values || [];
            } catch (error) {
                console.error(`Error loading (${range}):`, error);
                return [];
            }
        }

        function processImageUrl(originalUrl) {
            if (!originalUrl) return null;
            try {
                const url = new URL(originalUrl);
                if (url.hostname === '95.216.46.104') {
                    return IMAGE_PROXY + encodeURIComponent(url.href);
                }
                return originalUrl;
            } catch {
                return null;
            }
        }

        function extractFirstPhoto(photoString) {
            if (!photoString) return null;
            const photos = photoString.split(';')
                .map(url => url.trim())
                .filter(url => url.startsWith('http'));
            return photos.length > 0 ? photos[0] : null;
        }

        function formatPrice(price) {
            if (!price) return "Цена не указана";
            const numericPrice = parseFloat(price.toString().replace(/\s/g, '').replace(',', '.'));
            return isNaN(numericPrice) ? "Цена не указана" : `${numericPrice.toLocaleString('ru-RU')} ₴`;
        }

        function cleanSize(size) {
            if (!size) return "";
            return size.toString().replace('EU', '').replace('US', '').trim();
        }

        function validateProduct(item) {
            if (!item || !item.name || !item.brand) return false;
            
            if (FILTER_CONFIG.excludedBrands.includes(item.brand.trim())) return false;
            
            const lowerName = item.name.toLowerCase();
            const hasExcludedKeyword = FILTER_CONFIG.excludedKeywords.some(keyword =>
                lowerName.includes(keyword.toLowerCase())
            );
            
            return !hasExcludedKeyword;
        }

        function sortProducts(a, b) {
            const resolveType = (name, type) => {
                const lowerName = name.toLowerCase();
                const lowerType = type.toLowerCase();
                
                if (lowerType.includes('кросівки') || lowerName.includes('кросівки')) return 'Кросівки';
                if (lowerType.includes('кеди') || lowerName.includes('кеди')) return 'Кеди';
                if (lowerType.includes('черевики') || lowerName.includes('черевики')) return 'Черевики';
                if (lowerName.includes('аквашуз')) return 'Аквашузи';
                if (lowerName.includes('бутс')) return 'Бутси';
                if (lowerName.includes('крокс')) return 'Крокси';
                if (lowerName.includes('корал')) return 'Коралки';
                if (lowerName.includes("в'єтнам")) return "В'єтнамки";
                return type;
            };

            const typeA = resolveType(a.name, a.type);
            const typeB = resolveType(b.name, b.type);

            const priorityA = FILTER_CONFIG.typePriority[typeA] || FILTER_CONFIG.typePriority.default;
            const priorityB = FILTER_CONFIG.typePriority[typeB] || FILTER_CONFIG.typePriority.default;

            if (priorityA !== priorityB) return priorityA - priorityB;

            if (typeA === 'Кросівки' && typeB === 'Кросівки') {
                const isGenericA = a.name.trim().toLowerCase() === 'кросівки';
                const isGenericB = b.name.trim().toLowerCase() === 'кросівки';
                if (isGenericA !== isGenericB) return isGenericA ? 1 : -1;
            }

            return a.name.localeCompare(b.name);
        }

        function processData(shortData, longData) {
            const sizeMap = {};
            const priceMap = {};
            
            shortData.forEach(row => {
                const article = row?.[0]?.trim();
                const size = cleanSize(row?.[1]);
                const price = row?.[2];

                if (article) {
                    if (!sizeMap[article]) sizeMap[article] = new Set();
                    if (size) sizeMap[article].add(size);
                    
                    if (price) {
                        const numericPrice = parseFloat(price.toString().replace(/\s/g, '').replace(',', '.'));
                        if (!isNaN(numericPrice)) {
                            if (!priceMap[article] || numericPrice < priceMap[article]) {
                                priceMap[article] = numericPrice;
                            }
                        }
                    }
                }
            });

            const catalogItems = [];
            const uniqueArticles = new Set();

            longData.forEach(row => {
                const article = row?.[0]?.trim();
                const name = row?.[1]?.trim();
                const type = row?.[16]?.trim();
                const brand = row?.[15]?.trim();
                const photos = row?.[23];
                const longPrice = row?.[18];

                if (!article || !name || type !== "Взуття") return;
                if (uniqueArticles.has(article)) return;

                const product = {
                    article,
                    name,
                    brand: brand || "Не указан",
                    type: type || "Другой тип",
                    photo: processImageUrl(extractFirstPhoto(photos)),
                    sizes: sizeMap[article] ? Array.from(sizeMap[article]).sort() : ["Нет данных"],
                    price: formatPrice(priceMap[article] || longPrice)
                };

                if (validateProduct(product)) {
                    uniqueArticles.add(article);
                    catalogItems.push(product);
                }
            });

            return catalogItems;
        }

        // Остальной код из предыдущего ответа остается без изменений
        let allProducts = [];
        let currentPage = 1;
        let totalPages = 1;

        const dom = {
            catalog: document.getElementById('catalog'),
            searchInput: document.getElementById('searchInput'),
            brandFilter: document.getElementById('brandFilter'),
            typeFilter: document.getElementById('typeFilter'),
            sizeFilter: document.getElementById('sizeFilter'),
            sortSelect: document.getElementById('sortSelect'),
            pagination: document.getElementById('pagination')
        };

        async function loadCatalog() {
            try {
                showLoading();
                
                const [shortData, longData] = await Promise.all([
                    fetchSheet(SHEET_ID_SHORT, "TDSheet!A2:Z"),
                    fetchSheet(SHEET_ID_LONG, "TDSheet!A2:Z")
                ]);

                const processedData = processData(shortData, longData);
                allProducts = processedData.filter(validateProduct);
                
                initFilters(processedData);
                filterProducts();
            } catch (error) {
                showError(error);
            }
        }

        // Остальные функции (initFilters, populateFilter, filterProducts и т.д.)
        // сохраняются как в предыдущей версии ответа

        document.addEventListener('DOMContentLoaded', loadCatalog);
    </script>
</body>
</html>
